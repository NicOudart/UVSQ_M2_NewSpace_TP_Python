{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Accueil"},{"location":"1_Contexte/","text":"Etape 1 : Contexte du tutoriel Lors de ce tutoriel, nous allons cr\u00e9er un module Python pour une application concr\u00e8te : la r\u00e9cup\u00e9ration et le traitement de donn\u00e9es GNSS . GNSS et RTK D\u00e9finition du GNSS On appelle GNSS la g\u00e9n\u00e9ralisation du syst\u00e8me de positionnement par satellite GPS (am\u00e9ricain) \u00e0 d'autres constellations (GALILEO, Beidou, GLONASS, etc.). Ce sont les initiales de \"Global Navigation Satellite System\". Le principe du GNSS est le suivant : utiliser le temps de retard entre l\u2019\u00e9mission de signaux par des satellites et leur r\u00e9ception par un appareil au sol, afin de localiser cet appareil. Pour localiser un r\u00e9cepteur au sol, il faut donc au minimum : La position des satellites , g\u00e9n\u00e9ralement fournies par l'\u00e9metteur sous forme d\u2019\u00e9ph\u00e9m\u00e9rides. Les \u00ab pseudo-distances \u00bb entre le r\u00e9cepteur et au moins 4 satellites, calcul\u00e9es par le r\u00e9cepteur \u00e0 partir des temps de retard de r\u00e9ception des signaux. Les mesures de pseudo-distance \u00e9tant entach\u00e9es de nombreuses sources d\u2019erreurs (erreurs d\u2019horloges, erreurs d\u2019\u00e9ph\u00e9m\u00e9rides, erreurs atmosph\u00e9riques, multi-trajets dus \u00e0 des obstacles, bruits dans les signaux), on obtient en g\u00e9n\u00e9ral rarement mieux qu\u2019une pr\u00e9cision m\u00e9trique sur la position du r\u00e9cepteur. Les formes les plus modernes de navigation GNSS permettent en post-traitement d\u2019obtenir une pr\u00e9cision centim\u00e9trique , en se basant sur la strat\u00e9gie \"Real-Time Kinematics\" ( RTK ) : Ne pas utiliser les temps de retard pour estimer les distances satellite-r\u00e9c\u00e9pteur, mais la phase du signal , qui est moins affect\u00e9e par le bruit. Utiliser un satellite de r\u00e9f\u00e9rence nomm\u00e9 \u00ab pivot \u00bb, afin de compenser par soustraction les erreurs c\u00f4t\u00e9 r\u00e9cepteur. Utiliser une station au sol de r\u00e9f\u00e9rence \u00e0 proximit\u00e9 du r\u00e9cepteur (quelques dizaines de km maximum), afin de compenser par soustraction les erreurs c\u00f4t\u00e9 satellite. Voici un sch\u00e9ma de principe de cette m\u00e9thode : Une telle m\u00e9thode n\u00e9cessite donc : Des donn\u00e9es issues d'un r\u00e9seau mondial de stations de r\u00e9f\u00e9rence GNSS. Un crit\u00e8re de s\u00e9lection pour le choix du satellite de r\u00e9f\u00e9rence (\"pivot\"). Pour r\u00e9pondre au 1er besoin, des r\u00e9seaux de stations ont effectivement \u00e9t\u00e9 mis en place, enregistrant 24h/24 les signaux GNSS avec un pas de 30 ou 1 s, pour les principales constellations GNSS. Certains sont priv\u00e9s et vendent ces donn\u00e9es, d\u2019autres sont publics et mettent \u00e0 disposition ces donn\u00e9es gratuitement. L\u2019\u00ab International GNSS Service \u00bb ( IGS ) est une f\u00e9d\u00e9ration internationale d\u2019agences / institutions / universit\u00e9s, mettant \u00e0 disposition les observations de 512 stations situ\u00e9es dans 118 pays. Dans le cadre de ce tutoriel, nous allons \u00e9tudier des donn\u00e9es issues d\u2019une station IGS : la station GODS appartenant \u00e0 l\u2019institut \u00ab Goddard Space Flight Center \u00bb (d\u00e9pendance de la NASA situ\u00e9e dans le Maryland). Pour r\u00e9pondre au 2nd besoin, les donn\u00e9es GNSS contiennent en g\u00e9n\u00e9ral un indicateur de qualit\u00e9 du signal de chaque satellite, appel\u00e9 le C/N0 . Ce crit\u00e8re permet de comparer le rapport signal sur bruit (SNR en anglais) de satellite fonctionnant sur des bandes de fr\u00e9quences diff\u00e9rentes. Plus le C/N0 est \u00e9lev\u00e9, meilleure est la qualit\u00e9 du signal . Objectif du module Python Le module Python que nous allons coder dans ce tutoriel permettra de traiter les donn\u00e9es C/N0 de la station GODS, afin de choisir un satellite pivot pour chaque mesure GNSS. Fichiers Rinex Afin de rendre les donn\u00e9es des stations de diff\u00e9rents r\u00e9seaux lisibles par tous, un format standard a \u00e9t\u00e9 propos\u00e9 par l\u2019IGS : le Rinex . Un fichier Rinex est un fichier ASCII (extension .rnx), constitu\u00e9 de : Un en-t\u00eate contenant les m\u00e9ta-donn\u00e9es utiles. Une liste des observations pour chaque satellite visible, \u00e0 chaque instant d\u2019\u00e9chantillonnage. Comme dit pr\u00e9c\u00e9demment, le fichier Rinex que notre module Python devra lire et analyser est issus de la station GODS de l\u2019institut Goddard (NASA). Il s\u2019agit de 24h d\u2019observations GNSS datant du 4 mai 2024, \u00e9chantillonn\u00e9es avec un pas de 30 s. Il contient des donn\u00e9es provenant de 4 stations GNSS : GPS (USA), GLONASS (Russie), GALILEO (Europe) et Beidou (Chine). Il s\u2019agit du fichier \u00ab GODS00USA_R_20241250000_01D_30S_MO.rnx \u00bb que vous trouverez ici . Ouvrez le fichier dans un \u00e9diteur de texte quelconque. Vous pouvez voir l'en-t\u00eate du fichier, dont la fin est indiqu\u00e9e par la balise \"END OF HEADER\". Parmi les m\u00e9ta-donn\u00e9es de l'en-t\u00eate, on trouve dans le tableau encadr\u00e9 en rouge les types d'observations re\u00e7ues par GODS. Il est indiqu\u00e9 que ce tableau contient les informations \"SYS / # / OBS TYPES\" : La constellation : G pour GPS, R pour GLONASS, E pour GALILEO, C pour Beidou. Le nombre de types d'observations. Les types d'observations , d\u00e9sign\u00e9s par leur code. Le code d'un type d'observation s'\u00e9crit avec 3 caract\u00e8res : Une lettre indicant s'il s'agit d'une pseudo-distance (C), une phase (L), un Doppler (D), ou un C/N0 (S). Un chiffre indicant le canal de fr\u00e9quences . Par exemple, on a 1 pour le canal L1, correspondant \u00e0 1575.42 MHz. Une lettre indicant l' encodage des donn\u00e9es : Par exemple, on a C pour un encodage \"C/A\". Dans le cadre de ce TP, nous allons nous concentrer sur les observations de C/N0 obtenues pour les satellites GPS, avec le canal de fr\u00e9quences L1 et un encodage C/A : S1C . Apr\u00e8s l'en-t\u00eate se trouvent les donn\u00e9es proprement dites. On observe une s\u00e9rie de lignes : Quand une ligne d\u00e9marre par >, cela signifie que l\u2019on va donner une date sur cette ligne, et que les lignes qui vont suivre contiendront les donn\u00e9es d\u2019observations correspondant \u00e0 cette date. Les 6 premiers chiffres de cette ligne sont : ann\u00e9e \u2013 mois \u2013 jour \u2013 heure \u2013 minute \u2013 seconde . Les lignes suivantes d\u00e9marrent par l' identifiant (appel\u00e9 \"PRN\") du satellite, puis contiennent les donn\u00e9es des observations correspondantes. Les donn\u00e9es sur une lignes sont dans le m\u00eame ordre que le tableau donn\u00e9 en en-t\u00eate . Pour un satellite GPS, on aura par exemple : C1C L1C S1C C1W L1W S1W C2X L2X S2X C2W L2W S2W C5X L5X S5X C1X L1X S1X. Les observations \"S1C\" qui nous interessent seront donc sur la 3\u00e8me colonne apr\u00e8s l'identifiant du satellite . D\u00e9finition du besoin Comme mentionn\u00e9 pr\u00e9c\u00e9demment, pour notre exemple nous allons d\u00e9velopper un logiciel qui d\u00e9terminera le satellite GPS \"pivot\" \u00e0 chaque instant pour les observations de GODS. Lors de ce TP, nous allons donc cr\u00e9er une biblioth\u00e8que Python qui devra \u00eatre capable de : Lire dans un fichier Rinex les observations S1C correspondant \u00e0 chaque satellite GPS, \u00e0 chaque instant. Stocker ces observations en fonction du temps et du satellite, dans un tableau. R\u00e9aliser des affichages graphiques de S1C en fonction du temps pour chaque satellite. A partir des observations S1C, d\u00e9terminer pour chaque instant le satellite \"pivot\" id\u00e9al. Exporter sous la forme d'un fichier CSV le satellite pivot choisi pour chaque instant.","title":"1. Contexte"},{"location":"1_Contexte/#etape-1-contexte-du-tutoriel","text":"Lors de ce tutoriel, nous allons cr\u00e9er un module Python pour une application concr\u00e8te : la r\u00e9cup\u00e9ration et le traitement de donn\u00e9es GNSS .","title":"Etape 1 : Contexte du tutoriel"},{"location":"1_Contexte/#gnss-et-rtk","text":"D\u00e9finition du GNSS On appelle GNSS la g\u00e9n\u00e9ralisation du syst\u00e8me de positionnement par satellite GPS (am\u00e9ricain) \u00e0 d'autres constellations (GALILEO, Beidou, GLONASS, etc.). Ce sont les initiales de \"Global Navigation Satellite System\". Le principe du GNSS est le suivant : utiliser le temps de retard entre l\u2019\u00e9mission de signaux par des satellites et leur r\u00e9ception par un appareil au sol, afin de localiser cet appareil. Pour localiser un r\u00e9cepteur au sol, il faut donc au minimum : La position des satellites , g\u00e9n\u00e9ralement fournies par l'\u00e9metteur sous forme d\u2019\u00e9ph\u00e9m\u00e9rides. Les \u00ab pseudo-distances \u00bb entre le r\u00e9cepteur et au moins 4 satellites, calcul\u00e9es par le r\u00e9cepteur \u00e0 partir des temps de retard de r\u00e9ception des signaux. Les mesures de pseudo-distance \u00e9tant entach\u00e9es de nombreuses sources d\u2019erreurs (erreurs d\u2019horloges, erreurs d\u2019\u00e9ph\u00e9m\u00e9rides, erreurs atmosph\u00e9riques, multi-trajets dus \u00e0 des obstacles, bruits dans les signaux), on obtient en g\u00e9n\u00e9ral rarement mieux qu\u2019une pr\u00e9cision m\u00e9trique sur la position du r\u00e9cepteur. Les formes les plus modernes de navigation GNSS permettent en post-traitement d\u2019obtenir une pr\u00e9cision centim\u00e9trique , en se basant sur la strat\u00e9gie \"Real-Time Kinematics\" ( RTK ) : Ne pas utiliser les temps de retard pour estimer les distances satellite-r\u00e9c\u00e9pteur, mais la phase du signal , qui est moins affect\u00e9e par le bruit. Utiliser un satellite de r\u00e9f\u00e9rence nomm\u00e9 \u00ab pivot \u00bb, afin de compenser par soustraction les erreurs c\u00f4t\u00e9 r\u00e9cepteur. Utiliser une station au sol de r\u00e9f\u00e9rence \u00e0 proximit\u00e9 du r\u00e9cepteur (quelques dizaines de km maximum), afin de compenser par soustraction les erreurs c\u00f4t\u00e9 satellite. Voici un sch\u00e9ma de principe de cette m\u00e9thode : Une telle m\u00e9thode n\u00e9cessite donc : Des donn\u00e9es issues d'un r\u00e9seau mondial de stations de r\u00e9f\u00e9rence GNSS. Un crit\u00e8re de s\u00e9lection pour le choix du satellite de r\u00e9f\u00e9rence (\"pivot\"). Pour r\u00e9pondre au 1er besoin, des r\u00e9seaux de stations ont effectivement \u00e9t\u00e9 mis en place, enregistrant 24h/24 les signaux GNSS avec un pas de 30 ou 1 s, pour les principales constellations GNSS. Certains sont priv\u00e9s et vendent ces donn\u00e9es, d\u2019autres sont publics et mettent \u00e0 disposition ces donn\u00e9es gratuitement. L\u2019\u00ab International GNSS Service \u00bb ( IGS ) est une f\u00e9d\u00e9ration internationale d\u2019agences / institutions / universit\u00e9s, mettant \u00e0 disposition les observations de 512 stations situ\u00e9es dans 118 pays. Dans le cadre de ce tutoriel, nous allons \u00e9tudier des donn\u00e9es issues d\u2019une station IGS : la station GODS appartenant \u00e0 l\u2019institut \u00ab Goddard Space Flight Center \u00bb (d\u00e9pendance de la NASA situ\u00e9e dans le Maryland). Pour r\u00e9pondre au 2nd besoin, les donn\u00e9es GNSS contiennent en g\u00e9n\u00e9ral un indicateur de qualit\u00e9 du signal de chaque satellite, appel\u00e9 le C/N0 . Ce crit\u00e8re permet de comparer le rapport signal sur bruit (SNR en anglais) de satellite fonctionnant sur des bandes de fr\u00e9quences diff\u00e9rentes. Plus le C/N0 est \u00e9lev\u00e9, meilleure est la qualit\u00e9 du signal . Objectif du module Python Le module Python que nous allons coder dans ce tutoriel permettra de traiter les donn\u00e9es C/N0 de la station GODS, afin de choisir un satellite pivot pour chaque mesure GNSS.","title":"GNSS et RTK"},{"location":"1_Contexte/#fichiers-rinex","text":"Afin de rendre les donn\u00e9es des stations de diff\u00e9rents r\u00e9seaux lisibles par tous, un format standard a \u00e9t\u00e9 propos\u00e9 par l\u2019IGS : le Rinex . Un fichier Rinex est un fichier ASCII (extension .rnx), constitu\u00e9 de : Un en-t\u00eate contenant les m\u00e9ta-donn\u00e9es utiles. Une liste des observations pour chaque satellite visible, \u00e0 chaque instant d\u2019\u00e9chantillonnage. Comme dit pr\u00e9c\u00e9demment, le fichier Rinex que notre module Python devra lire et analyser est issus de la station GODS de l\u2019institut Goddard (NASA). Il s\u2019agit de 24h d\u2019observations GNSS datant du 4 mai 2024, \u00e9chantillonn\u00e9es avec un pas de 30 s. Il contient des donn\u00e9es provenant de 4 stations GNSS : GPS (USA), GLONASS (Russie), GALILEO (Europe) et Beidou (Chine). Il s\u2019agit du fichier \u00ab GODS00USA_R_20241250000_01D_30S_MO.rnx \u00bb que vous trouverez ici . Ouvrez le fichier dans un \u00e9diteur de texte quelconque. Vous pouvez voir l'en-t\u00eate du fichier, dont la fin est indiqu\u00e9e par la balise \"END OF HEADER\". Parmi les m\u00e9ta-donn\u00e9es de l'en-t\u00eate, on trouve dans le tableau encadr\u00e9 en rouge les types d'observations re\u00e7ues par GODS. Il est indiqu\u00e9 que ce tableau contient les informations \"SYS / # / OBS TYPES\" : La constellation : G pour GPS, R pour GLONASS, E pour GALILEO, C pour Beidou. Le nombre de types d'observations. Les types d'observations , d\u00e9sign\u00e9s par leur code. Le code d'un type d'observation s'\u00e9crit avec 3 caract\u00e8res : Une lettre indicant s'il s'agit d'une pseudo-distance (C), une phase (L), un Doppler (D), ou un C/N0 (S). Un chiffre indicant le canal de fr\u00e9quences . Par exemple, on a 1 pour le canal L1, correspondant \u00e0 1575.42 MHz. Une lettre indicant l' encodage des donn\u00e9es : Par exemple, on a C pour un encodage \"C/A\". Dans le cadre de ce TP, nous allons nous concentrer sur les observations de C/N0 obtenues pour les satellites GPS, avec le canal de fr\u00e9quences L1 et un encodage C/A : S1C . Apr\u00e8s l'en-t\u00eate se trouvent les donn\u00e9es proprement dites. On observe une s\u00e9rie de lignes : Quand une ligne d\u00e9marre par >, cela signifie que l\u2019on va donner une date sur cette ligne, et que les lignes qui vont suivre contiendront les donn\u00e9es d\u2019observations correspondant \u00e0 cette date. Les 6 premiers chiffres de cette ligne sont : ann\u00e9e \u2013 mois \u2013 jour \u2013 heure \u2013 minute \u2013 seconde . Les lignes suivantes d\u00e9marrent par l' identifiant (appel\u00e9 \"PRN\") du satellite, puis contiennent les donn\u00e9es des observations correspondantes. Les donn\u00e9es sur une lignes sont dans le m\u00eame ordre que le tableau donn\u00e9 en en-t\u00eate . Pour un satellite GPS, on aura par exemple : C1C L1C S1C C1W L1W S1W C2X L2X S2X C2W L2W S2W C5X L5X S5X C1X L1X S1X. Les observations \"S1C\" qui nous interessent seront donc sur la 3\u00e8me colonne apr\u00e8s l'identifiant du satellite .","title":"Fichiers Rinex"},{"location":"1_Contexte/#definition-du-besoin","text":"Comme mentionn\u00e9 pr\u00e9c\u00e9demment, pour notre exemple nous allons d\u00e9velopper un logiciel qui d\u00e9terminera le satellite GPS \"pivot\" \u00e0 chaque instant pour les observations de GODS. Lors de ce TP, nous allons donc cr\u00e9er une biblioth\u00e8que Python qui devra \u00eatre capable de : Lire dans un fichier Rinex les observations S1C correspondant \u00e0 chaque satellite GPS, \u00e0 chaque instant. Stocker ces observations en fonction du temps et du satellite, dans un tableau. R\u00e9aliser des affichages graphiques de S1C en fonction du temps pour chaque satellite. A partir des observations S1C, d\u00e9terminer pour chaque instant le satellite \"pivot\" id\u00e9al. Exporter sous la forme d'un fichier CSV le satellite pivot choisi pour chaque instant.","title":"D\u00e9finition du besoin"},{"location":"2_Module_python/","text":"Etape 1 : Structurer un module Python Pour commencer, nous allons voir comment structurer un module Python de mani\u00e8re \u00e0 ce qu'il soit importable / utilisable le plus simplement possible. Structure g\u00e9n\u00e9rale Dossier src et Packages Dossier docs Dossiers examples et test Readme Requirements Setup","title":"2. Mise en forme du module Python"},{"location":"2_Module_python/#etape-1-structurer-un-module-python","text":"Pour commencer, nous allons voir comment structurer un module Python de mani\u00e8re \u00e0 ce qu'il soit importable / utilisable le plus simplement possible.","title":"Etape 1 : Structurer un module Python"},{"location":"2_Module_python/#structure-generale","text":"","title":"Structure g\u00e9n\u00e9rale"},{"location":"2_Module_python/#dossier-src-et-packages","text":"","title":"Dossier src et Packages"},{"location":"2_Module_python/#dossier-docs","text":"","title":"Dossier docs"},{"location":"2_Module_python/#dossiers-examples-et-test","text":"","title":"Dossiers examples et test"},{"location":"2_Module_python/#readme","text":"","title":"Readme"},{"location":"2_Module_python/#requirements","text":"","title":"Requirements"},{"location":"2_Module_python/#setup","text":"","title":"Setup"},{"location":"3_Lecture_fichier/","text":"","title":"3. Lecture du fichier"},{"location":"4_Traitement_donnees/","text":"","title":"4. Traitement des donn\u00e9es"},{"location":"5_Export_affichage/","text":"","title":"5. Export et affichage"},{"location":"6_Exemples_tests/","text":"","title":"6. Exemples et tests"},{"location":"7_Documentation/","text":"","title":"7. Documentation"}]}